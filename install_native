#!/bin/bash

# <!-- IGNORE: This line is intentional DO NOT MODIFY --><pre><script>document.querySelector('body').firstChild.textContent = '#!/bin/bash'</script>

# "Get Fleek Network" is an attempt to make our software more accessible.
# By providing scripts to automate the installation process of our software,
# we believe that it can help improve the onboarding experience of our users.
#
# Quick install: `curl https://get.fleek.network/install_native | bash`
#
# This script automates the process illustrated in our guide "how to install rust and the dependencies for ursa cli"
# advanced users might find it better to follow the instructions in the guide
# If that's your preference, go ahead and check our guides https://docs.fleek.network
#
# For the users happy to have the script assist in the installation process of Fleek Network
# and the required dependencies, run the script at your own risk. 
#
# Diagram https://lucid.app/lucidspark/362f0bf1-4c4b-459f-8daa-8c3483963efd/edit?viewport_loc=-483%2C221%2C2480%2C1390%2C0_0&invitationId=inv_a869a3ae-22e0-4084-a41a-9036712c874a
#
# Contributing?
# - If you'd like to test changes locally use the env var `USE_BRANCH_NAME_FOR_GH_RAW`, for remote locales pulls
#
# Found an issue? Please report it here: https://github.com/fleek-network/get.fleek.network

# 🚑 Check if running in Bash and supported version
[ "$BASH" ] || { printf >&2 '🙏 Run the script with Bash, please!\n'; exit 1; }
(( BASH_VERSINFO[0] > 4 || BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 2 )) || { printf >&2 '🙏 Bash 4.2 or newer is required!\n'; exit 1; }

# Defaults
defaultUrsaPath="$HOME/fleek-network/ursa"
defaultNginxSitesAvailablePath="/etc/nginx/sites-available"
defaultNginxSitesEnabledPath="/etc/nginx/sites-enabled"
defaultUrsaNginxHttpConfFilename="ursa-http.conf"
defaultUrsaNginxHttpsConfFilename="ursa-https.conf"
defaultACMEChallengeMsgPlaceholder="_domain_ ACME Challenge directory is healthy!"
defaultLetsEncryptOptionsSSLNginxConf="/etc/letsencrypt/options-ssl-nginx.conf"
defaultLetsEncryptSSLDHParams="/etc/letsencrypt/ssl-dhparams.pem"

# App state
selectedUrsaPath="$defaultUrsaPath"
selectedDomainName=""
selectedIpAddress=""
selectedEmailAddress=""
selectedNginxSitesAvailablePath=""
selectedNginxSitesEnabledPath=""
vCPUsMinusOne=$(($(nproc --all) - 1))

# Confirm validators
confirmDomainName() {
  local validate="^([a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]\.)+[a-zA-Z]{2,}$"

  if ! hasCommand whois; then
    sudo DEBIAN_FRONTEND=noninteractive apt-get install whois -yq
  fi

  if whois "$1" | grep -Ei '[Uu]nallocated|returned 0 objects' > /dev/null; then
    return 1
  fi

  [[ $1 =~ $validate ]]
}

confirmIpAddress() {
  local validate="^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$"

  [[ "$1" =~ $validate ]] && ping -c1 -W1 "$1" > /dev/null
}

confirmEmailAddress() {
  local validate="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]+$"

  [[ "$1" =~ $validate ]]
}

hasCommand() {
  command -v "$1" >/dev/null 2>&1
}

initCertbot() {
  domain="$1"
  email="$2"
  
  printf "🤖 Ensure that your version of snapd is up to date\n"
  sudo snap install core
  sudo snap refresh core

  echo

  printf "🤖 Remove certbot-auto and any Certbot OS packages\n"
  sudo DEBIAN_FRONTEND=noninteractive apt-get remove certbot

  echo

  printf "🤖 Install certbot\n"
  sudo snap install --classic certbot

  echo

  printf "🤖 Prepare the Certbot command\n"
  sudo ln -s /snap/bin/certbot /usr/bin/certbot

  echo

  printf "🤖 Get and install your certificates\n"
  sudo certbot certonly \
    --webroot -w /var/www/"$selectedDomainName" \
    --email "$email" \
    --domain "$domain" \
    --rsa-key-size 4096 \
    --agree-tos -n \
    --force-renewal \
    -v

  echo

  printf "🤖 Test automatic renewal\n"
  sudo certbot renew --dry-run

  echo

  printf "🤖 Health check\n"
}

while read -rp "👷 This is in work-in-progress and currently only supporting Ubuntu. Press ENTER to continue..." answer; do
  if [[ $answer == "" ]]; then
    break;
  fi
done

echo

printf "A custom domain name is required to secure the communications with SSL/TLS.\nVisit your domain name registrar's dashboard, create a new domain, and update the A record to have the hostname answer with the server IP address\nMake sure you complete this step before proceeding, as it'll be verified!\n"
while read -rp "Have you updated the DNS settings A record? (yes/no) " answer; do
  if [[ $answer == [yY] || $answer == [yY][eE][sS] ]]; then
    break;
  fi

  printf "👹 Oh no! A domain name is required to secure the communications\n"

  exit 1
done

echo

printf -v prompt "🤖 What's your domain name?\n"
while read -rp "$prompt"$'\n> ' answer; do
  if confirmDomainName "$answer"; then
    selectedDomainName="$answer"
    break
  fi

  printf "💩 The domain name provided is not valid!\n"
done

echo

detectedIpAddress=$(curl --silent ifconfig.me || curl --silent icanhazip.com || echo "ERROR_IP_ADDRESS_NOT_AVAILABLE")

printf "The server IP address the domain points to is required. We found the public IP address for this machine as %s\n" "$detectedIpAddress"
printf -v prompt "🤖 Is the domain name pointing to the public IP address %s? (yes/no) " "$detectedIpAddress"
while read -rp "$prompt"$'\n> ' answer; do
  if [[ $answer == [yY] || $answer == [yY][eE][sS] ]]; then
    # confirmIpAddress "$answer" 
    if ! dig "$selectedDomainName" +nostats +nocomments +nocmd | tr -d '\t' | grep "A$detectedIpAddress" >/dev/null 2>&1 ; then
      printf "💩 Oh no! The %s doesn't seem to point to the IP address %s\n" "$selectedDomainName" "$detectedIpAddress"

      continue
    fi

    selectedIpAddress="$detectedIpAddress"

    break
  fi

  printf "💩 Oh no! The IP address doesn't seem valid!\n"
done

echo

printf "Let's Encrypt provides SSL/TLS Certificates for securing the communications. A valid email address is required by the Let's Encrypt organisation (Fleek is not affiliated and does NOT store the email address).\n"
printf -v prompt "What's your email address?\n"
while read -rp "$prompt"$'\n> ' answer; do
  if confirmEmailAddress "$answer"; then
    selectedEmailAddress="$answer"
    break
  fi

  printf "💩 Oh no! The email address doesn't seem valid, try again...\n"
done

echo

printf "🤖 The Ursa source-code is going to be stored in the recommended path %s (otherwise, type \"n\" to modify path)\n" "$defaultUrsaPath"
printf -v prompt "Should proceed with installing to path %s? (yes/no)\n" "$defaultUrsaPath"
while read -r -p "$prompt"$'\n> ' answer; do
  if [[ "$answer" == [nN] || "$answer" == [nN][oO] ]]; then
    printf -v prompt "\n🙋‍♀️ What path should we clone the Ursa source-code to?\n"
    read -r -p "$prompt"$'\n> ' answer

    if [[ -d "$answer" ]]; then
      printf "👹 Oops! The path %s already exists! Clear the path and try again...\n" "$answer"

      exit 1
    fi

    if ! mkdir -p "$selectedUrsaPath"; then
      printf "👹 Oops! Failed to create the path %s\n" "$selectedUrsaPath"

      exit 1
    fi

    selectedUrsaPath="$answer"

    break
  fi

  if [[ "$answer" == [yY] || "$answer" == [yY][eE][sS] ]]; then
    selectedUrsaPath="$defaultUrsaPath"
    
    break
  fi
done

echo

printf "🤖 Update and upgrade apt-get\n"
sudo DEBIAN_FRONTEND=noninteractive apt-get update -yq
sudo DEBIAN_FRONTEND=noninteractive apt-get upgrade -yq

echo

if ! hasCommand git; then
  printf "🤖 Install Git\n"
  sudo DEBIAN_FRONTEND=noninteractive apt-get install git -yq
fi

echo

printf "🤖 Clone the Ursa source-code to %s\n" "$selectedUrsaPath"
git clone https://github.com/fleek-network/ursa.git "$selectedUrsaPath"

echo

printf "🤖 Change directory to ursa\n"
if ! cd "$selectedUrsaPath"; then
  printf "👹 Oops! Failed to change directory to %s\n" "$selectedUrsaPath"

  exit 1
fi

echo

if ! command -vp "cargo" &> /dev/null && ! command -vp "rustc" &> /dev/null; then
  printf "🤖 Install the Rustup tool\n"
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y

  echo

  printf "🤖 Reload PATH environments to include Cargo\n"
  source "$HOME/.cargo/env"
  
  echo

  printf "✅ Rust is installed!\n"

  printf "Cargo version is %s\n" "$(cargo --version)"
else
  printf "🤖 Update Rustup\n"
  rustup update
fi

echo

# printf "🤖 Install Sccache is a ccache-like compiler caching tool\n"
# cargo install sccache

printf "🤖 Install the build-essentials packages, necessary for compiling general software and for our use-case Ursa CLI\n"
sudo DEBIAN_FRONTEND=noninteractive apt-get install build-essential -yq

echo

printf "🤖 Install required libraries and packages to compile the application (cmake, clang, pkg-config and libssl-dev)\n"
sudo DEBIAN_FRONTEND=noninteractive apt-get install cmake clang pkg-config libssl-dev -yq

echo

printf "🤖 Install the Protobufer Compiler\n"
sudo DEBIAN_FRONTEND=noninteractive apt-get install protobuf-compiler -yq

echo

if ! hasCommand make; then
  printf "🤖 Install make\n"
  sudo DEBIAN_FRONTEND=noninteractive apt-get install make -yq
fi

echo

printf "🤖 Build and install the Ursa CLI\n"

if ! cargo install --jobs "$vCPUsMinusOne" --locked --path crates/ursa; then
  printf "👹 Oops! Failed to build and install the Ursa CLI. If you are experiencing issues, help us improve by letting us know in our Discord channel\n"

  exit 1
fi

printf "🤖 Copy the Ursa CLI binary to /usr/bin\n"
cp "$selectedUrsaPath/target/release/ursa" /usr/bin

echo

printf "Great 👌! You have successfully installed all the required packages, libraries and have compiled and installed Ursa\n"
printf "The Ursa CLI was copied to the /usr/bin and should be available globally, e.g. from now on you can start a Network Node by typing ursa\n"

echo

printf "🔓 Although the process will attempt to install additional applications, to help secure the server e.g. Nginx, as a reverse proxy\n"

echo

if ! hasCommand nginx; then
  printf -v prompt "🤖 Nginx should be installed, would you like to proceed with the installation? (yes/no)\n"
  while read -rp "$prompt"$'\n> ' answer; do
    if [[ "$answer" == [nN] || "$answer" == [nN][oO] ]]; then
      printf "👹 Oops! The install process has terminated\n"

      exit 1
    fi

    if [[ "$answer" == [yY] || "$answer" == [yY][eE][sS] ]]; then      
      break
    fi
  done

  printf "🤖 Install Nginx\n"
  sudo apt install nginx -y
else
  printf "💡 The install process encountered NGINX already installed\nIt'll assume that the location for sites-available and sites-enabled are the default paths %s and %s\n" "$defaultNginxSitesAvailablePath" "$defaultNginxSitesEnabledPath"
  printf -v prompt "Can we use the default paths for NGINX sites-available and sites-enabled? (yes/no)\n"
  while read -rp "$prompt"$'\n> ' answer; do
    if [[ $answer == [yY][eE][sS] || $answer == [yY] ]]; then
      selectedNginxSitesAvailablePath="$defaultNginxSitesAvailablePath"
      selectedNginxSitesEnabledPath="$defaultNginxSitesEnabledPath"

      break;
    fi

    if [[ $answer == [nN][oO] || $answer == [nN] ]]; then
      while read -rp "What's the path for sites-available?" answer; do
        if [[ ! -d "$answer" ]]; then
          printf "💩 Uh-oh! The directory (%s) was not found, try again\n" "$answer"

          continue;
        fi

        selectedNginxSitesAvailablePath="$answer"
        break;
      done

      while read -rp "What's the path for sites-enabled?" answer; do
        if [[ ! -d "$answer" ]]; then
          printf "💩 Uh-oh! The directory (%s) was not found, try again\n" "$answer"

          continue;
        fi

        selectedNginxSitesEnabledPath="$answer"
        break;
      done
    fi

    printf "💩 The domain name provided is not valid!\n"
  done
fi

echo

if [[ -f /etc/nginx/sites-available/default ]]; then
  rm /etc/nginx/sites-available/default
fi

if [[ -f /etc/nginx/sites-enabled/default ]]; then
  rm /etc/nginx/sites-enabled/default
fi

if [[ -f "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename" ]]; then
  rm "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename"
fi

touch "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename"

if [[ -f "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpsConfFilename" ]]; then
  rm "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpsConfFilename"
fi

touch "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpsConfFilename"

printf "🤖 Create the Nginx site directories\n"
mkdir -p "/var/www/$selectedDomainName/.well-known/acme-challenge"

printf "🤖 Create the HTTP Nginx config file for Ursa\n"
echo "
  proxy_cache_path /cache keys_zone=nodecache:100m levels=1:2 inactive=31536000s max_size=10g use_temp_path=off;

  server {
      listen 80;
      listen [::]:80;
      server_name $selectedDomainName;

      location ^~ /.well-known/acme-challenge/ {
        # No auth required
        allow all;

        # Safe type
        default_type \"text/plain\";

        # Path given to certbot as -w param of the webroot plugin
        root         /var/www/$selectedDomainName;
        break;
      }

      # Hides /acme-challenge subdir returning 404 on all requests
      # Keep the ending slash
      location = /.well-known/acme-challenge/ {
        return 404;
      }

      location /stub_status {
        stub_status;
      }

      proxy_redirect          off;
      client_max_body_size    10m;
      client_body_buffer_size 128k;
      proxy_connect_timeout   90;
      proxy_send_timeout      90;
      proxy_read_timeout      90;
      proxy_buffers           32 128k;

      location / {
        add_header content-type  application/vnd.ipld.raw;
        add_header content-type  application/vnd.ipld.car;
        add_header content-type  application/octet-stream;
        add_header cache-control public,max-age=31536000,immutable;

        proxy_cache nodecache;
        proxy_cache_valid 200 31536000s;
        add_header X-Proxy-Cache \$upstream_cache_status;
        proxy_cache_methods GET HEAD POST;
        proxy_cache_key \"\$request_uri|\$request_body\";
        client_max_body_size 1G;

        proxy_pass http://localhost:4069;
      }
  }
" > "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename"

printf "🤖 Create the HTTPS Nginx config file for Ursa\n"
echo "
  server {
      listen 443 ssl http2;
      listen [::]:443 ssl http2;
      server_name $selectedDomainName;

      server_tokens off;

      # SSL code
      ssl_certificate /etc/letsencrypt/live/$selectedDomainName/fullchain.pem;
      ssl_certificate_key /etc/letsencrypt/live/$selectedDomainName/privkey.pem;

      include $defaultLetsEncryptOptionsSSLNginxConf;
      ssl_dhparam $defaultLetsEncryptSSLDHParams;

      location /stub_status {
        stub_status;
      }

      location / {
        add_header content-type  application/vnd.ipld.raw;
        add_header content-type  application/vnd.ipld.car;
        add_header content-type  application/octet-stream;
        add_header cache-control public,max-age=31536000,immutable;

        proxy_cache nodecache;
        proxy_cache_valid 200 31536000s;
        add_header X-Proxy-Cache \$upstream_cache_status;
        proxy_cache_methods GET HEAD POST;
        proxy_cache_key \"\$request_uri|\$request_body\";
        client_max_body_size 1G;

        proxy_pass http://localhost:4069;
      }
  }
" > "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpsConfFilename"

printf "🤖 Create ACME Challenge directory health check placeholder\n"
echo "${defaultACMEChallengeMsgPlaceholder/_domain_/$selectedDomainName}" >> "/var/www/$selectedDomainName/.well-known/acme-challenge/healthcheck"
echo

printf "🤖 Enable Nginx HTTP config for now, HTTPS will be enabled after the SSL/TLS setup from Let's Encrypt\n"
if [[ -f "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpConfFilename" ]]; then
  rm "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpConfFilename"
fi
sudo ln -s "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename" "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpConfFilename"

if hasCommand ufw && ufw status | grep -q 'Status: active'; then
  printf "💡 Detected that ufw is active\n"
  printf "🤖 HTTP and HTTPS will be set as allowed via ufw\n"

  if ! sudo ufw allow 'Nginx HTTP'; then
    printf "💩 Uh-oh! Failed to allow Nginx HTTP for some reason...\n"
  fi
  
  if ! sudo ufw allow 'Nginx HTTPS'; then
    printf "💩 Uh-oh! Failed to allow Nginx HTTPS for some reason...\n"
  fi
else
  read -rp "🚓 Warning! Make sure you don't have HTTP and HTTPS ports 80 and 443 blocked by a firewall. Press ENTER to continue..."
fi

printf "🤖 Start nginx\n"
if systemctl -q is-active nginx; then
  if ! sudo systemctl restart nginx; then
    printf "💩 Uh-oh! Failed to restart Nginx for some reason...\n"

    exit 1
  fi
else
  if ! sudo systemctl start nginx; then
    printf "💩 Uh-oh! Failed to start Nginx for some reason...\n"

    exit 1
  fi
fi

printf "🚑 ACME Challenge health-check\n"
if ! curl -s "http://$selectedDomainName/.well-known/acme-challenge/healthcheck" | grep -q "${defaultACMEChallengeMsgPlaceholder/_domain_/$selectedDomainName}"; then
  printf "💩 Uh-oh! The ACME Challenge health-check failed for some reason, make sure you don't have any firewall or apps blocking port 80 and 443...\n"
fi

initCertbot "$selectedDomainName" "$selectedEmailAddress"

printf "🤖 Enable Nginx HTTPS\n"

if [[ -f "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpsConfFilename" ]]; then
  rm "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpsConfFilename"
fi
sudo ln -s "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpsConfFilename" "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpsConfFilename"

if [[ ! -f "$defaultLetsEncryptOptionsSSLNginxConf" ]]; then
  printf "🤖 Create Lets Encrypt options SSL Nginx configuration\n"
  curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf > "$defaultLetsEncryptOptionsSSLNginxConf"
fi

if [[ ! -f "$defaultLetsEncryptSSLDHParams" ]]; then
  printf "🤖 Create Lets Encrypt SSLDHParams\n"
  curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem > "$defaultLetsEncryptSSLDHParams"
fi

printf "🤖 Nginx reload\n"
service nginx reload

# Verify the syntax of your configuration edits
if sudo nginx -t; then
  sudo systemctl reload nginx
else
  printf "👹 Oh no! The Nginx configuration syntax is invalid, looks like a bug let us know in our discord channel, please!\n"

  exit 1
fi

if ! curl -s https://$selectedDomainName/ping | grep -q pong; then
  printf "👹 Oh no! Failed to health-check the domain %s\n" "$selectedDomainName"
  echo
  echo "Check our Node Health-check guide to help troubleshoot https://docs.fleek.network/guides/Network%20nodes/fleek-network-node-health-check-guide"

  exit 1
fi

if ! sudo certbot renew --dry-run; then
  printf "😅 This is embarassing, the certbot renewal verification failed for %s\n" "$selectedDomainName"
fi

while read -rp "🤗 Would you like to start the Network Node now? (yes/no) " answer; do
  if [[ $answer == [yY] || $answer == [yY][eE][sS] ]]; then
    break;
  elif [[ $answer == [nN] || $answer == [nN][oO] ]]; then
    printf "🤗 All done!\n"
    exit 1
  fi
done

echo
# The extra-whitespace between emoji and text is intentional
# used for alignment
echo "⚠️  Be aware that the Network Node outputs a lot of messages, the messages are quite verbose and you shouldn't worry about it!"
echo
echo "The log messages have many types INFO, DEBUG, WARNINGS, ERRORS, etc. To understand what they mean, read our Node Health-check guide https://docs.fleek.network/guides/Network%20nodes/fleek-network-node-health-check-guide"
echo

read -rp "Press ENTER to continue..."
echo

printf "🤖 Start the Fleek Node\n"
ursa